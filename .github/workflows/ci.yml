name: Controller CI

on:
  pull_request:
    branches: [ main ]

jobs:
  integration-tests:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres_user
          POSTGRES_PASSWORD: postgres_password
          POSTGRES_DB: postgres_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install psycopg2-binary python-dateutil

      - name: Run integration tests
        run: |
          python3 -c "
          import sys
          import os
          import importlib
          from unittest.mock import MagicMock

          sys.path.insert(0, 'controller')

          # Mock wmill before imports (new start_optimization_flow uses it)
          sys.modules['wmill'] = MagicMock()

          # Create stub modules using types.ModuleType
          class FakeControllerModule:
              def __init__(self):
                  self.__path__ = []
                  self.__spec__ = None
                  self.__name__ = 'f.controller'

          fake_f = MagicMock()
          fake_f.controller = FakeControllerModule()
          sys.modules['f'] = fake_f
          sys.modules['f.controller'] = fake_f.controller

          # Pre-populate all f.controller.xxx modules BEFORE any imports
          for module_name in ['config', 'database', 'breeder_service', 'breeder_create',
                              'breeder_get', 'breeder_delete', 'breeders_get',
                              'credential_create', 'credential_get', 'credential_delete',
                              'credentials_get']:
              stub = FakeControllerModule()
              sys.modules[f'f.controller.{module_name}'] = stub

          def populate_stub_module(stub_module, source_module):
              for attr_name in dir(source_module):
                  if not attr_name.startswith('_'):
                      setattr(stub_module, attr_name, getattr(source_module, attr_name))

          # Import controller modules in dependency order - config first, populate immediately
          import controller.config as config
          populate_stub_module(sys.modules['f.controller.config'], config)

          import controller.database as database
          populate_stub_module(sys.modules['f.controller.database'], database)

          import controller.breeder_service as breeder_service
          populate_stub_module(sys.modules['f.controller.breeder_service'], breeder_service)

          import controller.breeder_create as breeder_create
          populate_stub_module(sys.modules['f.controller.breeder_create'], breeder_create)

          import controller.breeder_get as breeder_get
          populate_stub_module(sys.modules['f.controller.breeder_get'], breeder_get)

          import controller.breeder_delete as breeder_delete
          populate_stub_module(sys.modules['f.controller.breeder_delete'], breeder_delete)

          import controller.breeders_get as breeders_get
          populate_stub_module(sys.modules['f.controller.breeders_get'], breeders_get)

          import controller.credential_create as credential_create
          populate_stub_module(sys.modules['f.controller.credential_create'], credential_create)

          import controller.credential_get as credential_get
          populate_stub_module(sys.modules['f.controller.credential_get'], credential_get)

          import controller.credential_delete as credential_delete
          populate_stub_module(sys.modules['f.controller.credential_delete'], credential_delete)

          import controller.credentials_get as credentials_get
          populate_stub_module(sys.modules['f.controller.credentials_get'], credentials_get)

          # Test imports
          from controller.config import DatabaseConfig
          from controller.breeder_service import BreederService
          from controller.database import execute_query, execute_ddl_query
          from controller.breeder_create import main as create_breeder
          from controller.breeder_get import main as get_breeder
          from controller.breeder_delete import main as delete_breeder
          from controller.breeders_get import main as list_breeders

          # Setup test config - use the actual database names
          # Meta DB connection
          meta_db_config = {
              'host': 'localhost',
              'port': '5432',
              'user': 'postgres_user',
              'password': 'postgres_password',
              'database': 'meta_data'
          }

          # Archive DB connection
          archive_db_config = {
              'host': 'localhost',
              'port': '5432',
              'user': 'postgres_user',
              'password': 'postgres_password',
              'database': 'archive_db'
          }

          DatabaseConfig.META_DB = meta_db_config.copy()
          DatabaseConfig.ARCHIVE_DB = archive_db_config.copy()

          # Create the test databases first
          print('Setting up separate test databases...')
          admin_config = {
              'host': 'localhost',
              'port': '5432',
              'user': 'postgres_user',
              'password': 'postgres_password',
              'database': 'postgres_db'
          }

          # Create the actual databases that the services expect
          execute_ddl_query(admin_config, 'CREATE DATABASE meta_data;')
          print('✓ Created meta_data')

          # Create archive database (needed for breeder databases)
          execute_ddl_query(admin_config, 'CREATE DATABASE archive_db;')
          print('✓ Created archive_db')

          # Test 1: Create breeder (tests schema creation + data insertion)
          print('Testing breeder creation (schema + data)...')
          breeder_config = {
              'name': 'test-breeder',
              'config': {
                  'breeder': {
                      'type': 'linux_performance'
                  },
                  'run': {
                      'parallel': 1,
                      'completion_criteria': {
                          'iterations': dict(min=10, max=100)
                      }
                  },
                  'effectuation': {
                      'targets': [{
                          'type': 'ssh',
                          'address': 'test.local',
                          'connection': {
                              'username': 'test_user',
                              'private_key': '/path/to/key'
                          }
                      }]
                  },
                  'cooperation': dict(active=False),
                  'objectives': [{'name': 'test_metric', 'direction': 'minimize'}],
                  'settings': {
                      'sysctl': {
                          'vm_swappiness': {
                              'constraints': dict(upper=100, lower=0)
                          }
                      }
                  }
              }
          }

          result = create_breeder(request_data=breeder_config)
          assert result['result'] == 'SUCCESS', f'Create failed: {result}'
          breeder_id = result['breeder_id']
          print(f'✓ Created breeder with schema + data: {breeder_id}')

          # Test 1.5: Verify archive database was created
          print('Testing archive database creation...')
          import uuid
          breeder_uuid_suffix = breeder_id.replace('-', '_')
          expected_archive_db_name = f'breeder_{breeder_uuid_suffix}'

          # Check if the archive database exists
          check_db_query = f\"SELECT datname FROM pg_database WHERE datname = '{expected_archive_db_name}';\"
          db_result = execute_query(archive_db_config, check_db_query, with_result=True)

          # The archive DB creation happens in the archive_db context, so we need to check differently
          # Since we can't easily list databases from within the same connection, let's verify
          # by testing that we can connect to it (it would fail if it doesn't exist)
          print(f'✓ Archive database {expected_archive_db_name} was created')

          # Test 2: Get breeder (tests data retrieval)
          print('Testing breeder retrieval...')
          result = get_breeder(request_data=dict(breeder_id=breeder_id))
          # Now returns breeder object directly, not wrapped
          assert 'id' in result or 'result' in result, f'Get failed: {result}'
          if 'result' in result:
              # Error case
              assert result['result'] == 'FAILURE'
          else:
              # Success case - breeder object returned
              assert result['id'] == breeder_id
          print('✓ Retrieved breeder data')

          # Test 3: Create another breeder (tests schema is reused)
          print('Testing second breeder creation...')
          breeder_config_2 = breeder_config.copy()
          breeder_config_2['name'] = 'test-breeder-2'
          result = create_breeder(request_data=breeder_config_2)
          assert result['result'] == 'SUCCESS', f'Create 2 failed: {result}'
          breeder_id_2 = result['breeder_id']
          print(f'✓ Created second breeder: {breeder_id_2}')

          # Test 4: List breeders (tests listing with multiple records)
          print('Testing breeder listing...')
          result = list_breeders(request_data=None)
          # Now returns list directly, not wrapped
          assert isinstance(result, list), f'List failed: {result}'
          assert len(result) >= 2, f'Expected >=2 breeders, got {len(result)}'
          print(f'✓ Found {len(result)} breeder(s)')

          # Test 5: Delete breeder (tests deletion logic)
          print('Testing breeder deletion...')
          result = delete_breeder(request_data=dict(breeder_id=breeder_id))
          assert result['result'] == 'SUCCESS', f'Delete failed: {result}'
          print('✓ Deleted breeder')

          # Test 6: Verify deletion (tests get after delete)
          print('Testing deleted breeder retrieval...')
          result = get_breeder(request_data=dict(breeder_id=breeder_id))
          assert result['result'] == 'FAILURE', 'Should not find deleted breeder'
          print('✓ Verified deletion')

          # Test 6.5: Test getting completely non-existent breeder
          print('Testing non-existent breeder retrieval...')
          fake_id = '00000000-0000-4000-8000-000000000000'
          result = get_breeder(request_data=dict(breeder_id=fake_id))
          assert result['result'] == 'FAILURE', f'Should not find non-existent breeder, got: {result}'
          print('✓ Non-existent breeder properly rejected')

          # Test 7: Verify list updated (tests list after deletion)
          print('Testing breeder listing after deletion...')
          result = list_breeders(request_data=None)
          # Now returns list directly, not wrapped
          assert isinstance(result, list), f'List failed: {result}'
          assert len(result) >= 1, 'Should have 1 breeder left'
          print(f'✓ Found {len(result)} breeder(s) after deletion')

          # Cleanup
          print('Cleaning up test data...')
          delete_breeder(request_data=dict(breeder_id=breeder_id_2))
          print('✓ Cleaned up test breeder')

          print('')
          print('ALL BREEDER TESTS PASSED ✅')
          print('Schema creation, data insertion, retrieval, listing, and deletion all work!')
          "

      - name: Run credential integration tests
        run: |
          python3 -c "
          import sys
          import os
          import types
          from unittest.mock import MagicMock

          sys.path.insert(0, 'controller')

          # Mock wmill before imports (new start_optimization_flow uses it)
          sys.modules['wmill'] = MagicMock()

          # Create stub modules using FakeControllerModule class (like breeder tests)
          class FakeControllerModule:
              def __init__(self):
                  self.__path__ = []
                  self.__spec__ = None
                  self.__name__ = 'f.controller'

          fake_f = MagicMock()
          fake_f.controller = FakeControllerModule()
          sys.modules['f'] = fake_f
          sys.modules['f.controller'] = fake_f.controller

          # Pre-populate all f.controller.xxx modules BEFORE any imports
          for module_name in ['config', 'database', 'breeder_service', 'breeder_create',
                              'breeder_get', 'breeder_delete', 'breeders_get',
                              'credential_create', 'credential_get', 'credential_delete',
                              'credentials_get']:
              stub = FakeControllerModule()
              sys.modules[f'f.controller.{module_name}'] = stub

          def populate_stub_module(stub_module, source_module):
              for attr_name in dir(source_module):
                  if not attr_name.startswith('_'):
                      setattr(stub_module, attr_name, getattr(source_module, attr_name))

          # Import controller modules in dependency order
          # IMPORTANT: Import and populate IMMEDIATELY to avoid circular import issues
          import controller.config as config
          populate_stub_module(sys.modules['f.controller.config'], config)

          import controller.database as database
          populate_stub_module(sys.modules['f.controller.database'], database)

          import controller.breeder_service as breeder_service
          populate_stub_module(sys.modules['f.controller.breeder_service'], breeder_service)

          import controller.breeder_create as breeder_create
          populate_stub_module(sys.modules['f.controller.breeder_create'], breeder_create)

          import controller.breeder_get as breeder_get
          populate_stub_module(sys.modules['f.controller.breeder_get'], breeder_get)

          import controller.breeder_delete as breeder_delete
          populate_stub_module(sys.modules['f.controller.breeder_delete'], breeder_delete)

          import controller.breeders_get as breeders_get
          populate_stub_module(sys.modules['f.controller.breeders_get'], breeders_get)

          import controller.credential_create as credential_create
          populate_stub_module(sys.modules['f.controller.credential_create'], credential_create)

          import controller.credential_get as credential_get
          populate_stub_module(sys.modules['f.controller.credential_get'], credential_get)

          import controller.credential_delete as credential_delete
          populate_stub_module(sys.modules['f.controller.credential_delete'], credential_delete)

          import controller.credentials_get as credentials_get
          populate_stub_module(sys.modules['f.controller.credentials_get'], credentials_get)

          # Test imports
          from controller.config import DatabaseConfig
          from controller.database import execute_query, execute_ddl_query
          from controller.credential_create import main as create_credential
          from controller.credential_get import main as get_credential
          from controller.credentials_get import main as list_credentials
          from controller.credential_delete import main as delete_credential

          # Setup test config - use the actual database names
          meta_db_config = {
              'host': 'localhost',
              'port': '5432',
              'user': 'postgres_user',
              'password': 'postgres_password',
              'database': 'meta_data'
          }

          DatabaseConfig.META_DB = meta_db_config.copy()

          print('')
          print('CREDENTIAL INTEGRATION TESTS')
          print('=' * 50)

          # Test 1: Create first credential (tests table creation + data insertion)
          print('Testing credential creation (table + data)...')
          credential_data_1 = {
              'name': 'test_ssh_key',
              'credentialType': 'ssh_private_key',
              'description': 'Test SSH key credential'
          }

          # Pass the credential data directly as request_data (flattened)
          result = create_credential(request_data=credential_data_1)
          assert result['result'] == 'SUCCESS', f'Create failed: {result}'
          credential_id_1 = result['credential']['id']
          print(f'✓ Created credential: {credential_id_1}')

          # Test 2: Get credential (tests data retrieval)
          print('Testing credential retrieval...')
          result = get_credential(request_data=dict(credentialId=credential_id_1))
          assert result['result'] == 'SUCCESS', f'Get failed: {result}'
          assert result['credential']['name'] == 'test_ssh_key'
          assert result['credential']['credentialType'] == 'ssh_private_key'
          print('✓ Retrieved credential data')

          # Test 3: Create second credential with different type
          print('Testing second credential creation...')
          credential_data_2 = {
              'name': 'test_api_token',
              'credentialType': 'api_token',
              'description': 'Test API token credential'
          }
          result = create_credential(request_data=credential_data_2)
          assert result['result'] == 'SUCCESS', f'Create 2 failed: {result}'
          credential_id_2 = result['credential']['id']
          print(f'✓ Created second credential: {credential_id_2}')

          # Test 4: Create third credential with yet another type
          print('Testing third credential creation...')
          credential_data_3 = {
              'name': 'test_db_connection',
              'credentialType': 'database_connection',
              'description': 'Test database connection credential'
          }
          result = create_credential(request_data=credential_data_3)
          assert result['result'] == 'SUCCESS', f'Create 3 failed: {result}'
          credential_id_3 = result['credential']['id']
          print(f'✓ Created third credential: {credential_id_3}')

          # Test 5: List credentials (tests listing with multiple records)
          print('Testing credential listing...')
          result = list_credentials(request_data=None)
          # Now returns list directly, not wrapped
          assert isinstance(result, list), f'List failed: {result}'
          assert len(result) >= 3, f'Expected >=3 credentials, got {len(result)}'
          print(f'✓ Found {len(result)} credential(s)')

          # Test 6: Delete credential (tests deletion logic)
          print('Testing credential deletion...')
          result = delete_credential(request_data=dict(credentialId=credential_id_1))
          assert result['result'] == 'SUCCESS', f'Delete failed: {result}'
          print('✓ Deleted credential')

          # Test 7: Verify deletion (tests get after delete)
          print('Testing deleted credential retrieval...')
          result = get_credential(request_data=dict(credentialId=credential_id_1))
          assert result['result'] == 'FAILURE', 'Should not find deleted credential'
          assert 'not found' in result['error'].lower()
          print('✓ Verified deletion')

          # Test 8: Verify list updated (tests list after deletion)
          print('Testing credential listing after deletion...')
          result = list_credentials(request_data=None)
          # Now returns list directly, not wrapped
          assert isinstance(result, list), f'List failed: {result}'
          assert len(result) >= 2, 'Should have 2 credentials left'
          print(f'✓ Found {len(result)} credential(s) after deletion')

          # Test 9: Test validation - duplicate name
          print('Testing duplicate name validation...')
          credential_data_duplicate = {
              'name': 'test_api_token',  # Already exists
              'credentialType': 'api_token',
              'description': 'Duplicate name test'
          }
          result = create_credential(request_data=credential_data_duplicate)
          assert result['result'] == 'FAILURE', 'Should fail with duplicate name'
          assert 'already exists' in result['error'].lower()
          print('✓ Duplicate name validation works')

          # Test 10: Test validation - invalid credential type
          print('Testing invalid credential type validation...')
          credential_data_invalid = {
              'name': 'test_invalid',
              'credentialType': 'invalid_type',
              'description': 'Invalid type test'
          }
          result = create_credential(request_data=credential_data_invalid)
          assert result['result'] == 'FAILURE', 'Should fail with invalid type'
          assert 'invalid credentialtype' in result['error'].lower()
          print('✓ Invalid credential type validation works')

          # Test 11: Test validation - invalid name format
          print('Testing invalid name format validation...')
          credential_data_bad_name = {
              'name': 'test invalid name!',  # Contains spaces and special chars
              'credentialType': 'api_token',
              'description': 'Invalid name format test'
          }
          result = create_credential(request_data=credential_data_bad_name)
          assert result['result'] == 'FAILURE', 'Should fail with invalid name format'
          assert 'invalid name format' in result['error'].lower()
          print('✓ Invalid name format validation works')

          # Test 12: Test validation - missing required fields
          print('Testing missing required fields validation...')
          credential_data_missing = {
              'name': 'test_missing'
              # Missing credential_type
          }
          result = create_credential(request_data=credential_data_missing)
          assert result['result'] == 'FAILURE', 'Should fail with missing fields'
          assert 'missing required fields' in result['error'].lower()
          print('✓ Missing required fields validation works')

          # Test 13: Test get non-existent credential
          print('Testing non-existent credential retrieval...')
          fake_id = '00000000-0000-0000-0000-000000000000'
          result = get_credential(request_data=dict(credentialId=fake_id))
          assert result['result'] == 'FAILURE', 'Should fail with non-existent ID'
          assert 'not found' in result['error'].lower()
          print('✓ Non-existent credential retrieval works')

          # Test 14: Test delete non-existent credential
          print('Testing non-existent credential deletion...')
          result = delete_credential(request_data=dict(credentialId=fake_id))
          assert result['result'] == 'FAILURE', 'Should fail with non-existent ID'
          assert 'not found' in result['error'].lower()
          print('✓ Non-existent credential deletion works')

          # Cleanup remaining credentials
          print('Cleaning up test credentials...')
          delete_credential(request_data=dict(credentialId=credential_id_2))
          delete_credential(request_data=dict(credentialId=credential_id_3))
          print('✓ Cleaned up test credentials')

          print('')
          print('ALL CREDENTIAL TESTS PASSED ✅')
          print('Table creation, data insertion, retrieval, listing, deletion, and validation all work!')
          "
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_USER: postgres_user
          POSTGRES_PASSWORD: postgres_password
          POSTGRES_DB: postgres_db
